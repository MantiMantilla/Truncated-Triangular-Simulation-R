[["index.html", "Simulating the Truncated Triangular Distribution 1 Intro 1.1 Motivation 1.2 Your own flare 1.3 Project home 1.4 Disclaimer 1.5 Acknowledgments 1.6 Author 1.7 License", " Simulating the Truncated Triangular Distribution Alejandro Mantilla 2021-01-22 1 Intro 1.1 Motivation The triangular distribution is a thoroughly studied probability density function (PDF) that usually arises to describe the behavior of a real (\\(\\mathbb{R}\\)) random variable for which little information is available. The distribution is an easy fit for most practical scenarios and, as such, makes it extremely versatile as a means to model non-deterministic scenarios mathematically. To further aid our analysis, we consider the truncated distribution, a generic term that encompasses a transform of any given PDF such that it remains a PDF after restricting the function’s domain to an interval within. Our end goal is to perform a few analytical procedures to find parameterized expressions for a few major descriptive statistics and functions (such as the CDF) of both distributions and implement them in the R language. To show how one may realistically use these implementations we will explore a practical example wherein a triangular distribution and a corresponding truncated triangular distribution are constructed using our implementation and then used to generate random samples with Monte Carlo simulation. 1.2 Your own flare Those familiar with object-oriented programming might notice our approach takes after a few basic concepts such as constructor functions and composition. If this sounds interesting to you, I encourage you to add your own twist to this exercise and use classes instead of lists but know that it is not a must and we will be using only the most rudimentary features R has to offer. This implementation was designed with adaptability in mind, meaning that the same approach should also be compatible with other scripting languages such as Python or JavaScript. Plots aside, no external packages or libraries are required, though we use base R’s plot() family of functions which come pre-installed. 1.3 Project home All documents, markdown files, scripts, and project images are publicly available in this repository. 1.4 Disclaimer All errors are my own. All feedback is welcome. 1.5 Acknowledgments Special thanks to Alfaima Solano from Universidad de los Andes for their feedback on this project. 1.6 Author Alejandro Mantilla Data Scientist and Engineer Bogotá, Colombia 1.7 License Copyright (c) 2021 Alejandro Mantilla "],["triangular-distribution.html", "2 Triangular Distribution 2.1 Distributions 2.2 Triangular PDF 2.3 Triangular CDF 2.4 Inverse Triangular CDF 2.5 Measures of Central Tendency and Spread 2.6 An Object to Hold These Properties", " 2 Triangular Distribution 2.1 Distributions Probability density functions describe how likely it is for a continuous random variable \\(X\\) to fall within some region of its domain. For any single point the probability is cero but at intervals we can calculate the integral of the PDF and find the corresponding probability. Consider the following conventions: Let \\(X\\) be a random variable with distribution \\(f(x)\\) This way of defining random variables lets on some basic information about how it may behave but is lengthy and unnecessary. Let \\(X\\sim f(x)\\) Much better. Let \\(X\\sim f(x) = \\frac{e^{-\\frac{1}{2}\\left( \\frac{x-\\mu}{\\sigma}\\right)^{2}}}{\\sigma \\sqrt{2\\pi}}\\) A PDF will sometimes be defined for the entire real number line in a single expression like the ubiquitous normal distribution, while others require you to write piecewise functions such as the triangular distribution. Let \\(X\\sim Norm(\\mu, \\sigma^{2})\\) and \\(Y\\sim Triangular(L,U,M)\\) We use a shorthand notation for widely used distributions that would usually take too much effort to remember or write out. 2.2 Triangular PDF The triangular distribution specifically has the following PDF. \\[ f(x)= \\begin{cases} \\frac{2(x-L)}{(U-L)(M-L)}\\quad&amp;(L\\leq x&lt;M)\\\\ \\frac{2(U-x)}{(U-L)(U-M)}\\quad&amp;(M\\leq x\\leq U)\\\\ \\end{cases} \\] Though complicated at first sight, it really just describes two lines that form a triangle with the \\(x\\) axis. \\(L\\) and \\(U\\) stand for the lower and upper values that delimit the distribution and \\(M\\) is the mode. The function is explicit for when its value is different from cero, meaning we exclude the self-evident conditions for which it’s cero. Let’s start writing some code and see some plots of this distribution in action. triangular.distribution &lt;- function(x, L, U, M) { if (x &lt; L) { result &lt;- 0 } else if (x &lt; M) { result &lt;- 2 * (x - L) / ((U - L) * (M - L)) } else if (x == M) { result &lt;- 2 / (U - L) } else if (x &lt;= U) { result &lt;- 2 * (U - x) / ((U - L) * (U - M)) } else if (U &lt; x) { result &lt;- 0 } return(result) } This function takes some x and evaluates the triangular PDF defined by \\(L\\), \\(U\\), and \\(M\\) on it. triangular.distribution.vectorized &lt;- function(x, ...) { sapply(x, triangular.distribution, ...) } Because of the nature of the plot.function() method, we must make our function compatible with vectors, meaning that passing a vector as its x parameter would apply the function to every element in it. Notice the .... This just means that any subsequent parameters get passed to the underlying triangular.distribution() function. plot.function( function(x) {triangular.distribution.vectorized(x, 2, 9, 7)}, from = 2, to = 9, main = &quot;Triangular Distributions&quot;, ylab = &quot;f(x)&quot;, ylim = c(0, 0.5) ) ## Additional plots get included in the first rather than into a new canvas ## when the `add` parameter is set to TRUE. plot.function( function(x) {triangular.distribution.vectorized(x, 3, 8, 7)}, from = 2, to = 9, col = &quot;red&quot;, add = TRUE ) plot.function( function(x) {triangular.distribution.vectorized(x, 2, 8.5, 2)}, from = 1.9999999, to = 9, col = &quot;blue&quot;, add = TRUE ) ## Let&#39;s also include a legend so we can distinguish all three distributions. legend( x = 2, y = 0.5, legend = c(&quot;Triang(2, 9, 7)&quot;, &quot;Triang(3, 8, 7)&quot;, &quot;Triang(2, 8.5, 2)&quot;), col = c(&quot;black&quot;, &quot;red&quot;, &quot;blue&quot;), lty = 1 ) Notice how our distributions take the shape of a triangle when \\(x\\) falls within the interval of \\(L\\) and \\(U\\) but is cero everywhere else. 2.3 Triangular CDF The PDF alone won’t do us much good, considering how we still need to calculate probabilities somehow (remember, at any point the probability of a continuous random variable is 0). Let us define the CDF as the probability that our random variable \\(X\\) is smaller than some value \\(x\\). Or in mathematical notation: \\[ F(x) = P\\left( X \\leq x \\right) = \\int_{-\\infty}^{x}f(t)dt = \\int_{L}^{x}f(t)dt \\] The PDF is defined by two continuous lines and so it follows that we could compute the integral from negative infinity to some \\(x\\) to be: \\[ F(x)= \\begin{cases} \\frac{(x-L)^{2}}{(U-L)(M-L)}\\quad&amp;(L\\leq x&lt;M)\\\\ 1 - \\frac{(U-x)^{2}}{(U-L)(U-M)}\\quad&amp;(M\\leq x\\leq U)\\\\ 1 \\quad&amp; (U &lt; x)\\\\ \\end{cases} \\] We can now implement this in R in similar fashion to our PDF. cumulative.triangular.distribution &lt;- function(x, L, U, M) { if (x &lt; L) { result &lt;- 0 } else if (x &lt;= M) { result &lt;- (x - L) ^ 2 / ((U - L) * (M - L)) } else if (x &lt; U) { result &lt;- 1 - (U - x) ^ 2 / ((U - L) * (U - M)) } else if (U &lt;= x) { result &lt;- 1 } return(result) } cumulative.triangular.distribution.vectorized &lt;- function(x, ...) { sapply(x, cumulative.triangular.distribution, ...) } The code for the plots also shouldn’t change much. No change has been made to the parameters of each distribution. plot.function( function(x) {cumulative.triangular.distribution.vectorized(x, 2, 9, 7)}, from = 0, to = 10, main = &quot;Cumulative Triangular Distributions&quot;, ylab = &quot;F(x)&quot;, ylim = c(0, 1) ) plot.function( function(x) {cumulative.triangular.distribution.vectorized(x, 3, 8, 7)}, from = 0, to = 10, col = &quot;red&quot;, add = TRUE ) plot.function( function(x) {cumulative.triangular.distribution.vectorized(x, 2, 8.5, 2)}, from = 0, to = 10, col = &quot;blue&quot;, add = TRUE ) legend( x = 0, y = 1, legend = c(&quot;F(x)|f(x)=Triang(2, 9, 7)&quot;, &quot;F(x)|f(x)=Triang(3, 8, 7)&quot;, &quot;F(x)|f(x)=Triang(2, 8.5, 2)&quot;), col = c(&quot;black&quot;, &quot;red&quot;, &quot;blue&quot;), lty = 1 ) Notice how the cumulative distribution approaches and becomes one very quickly. This makes sense considering that, because of the bounds of the domain of the triangular distribution, \\(X\\) is guaranteed to be smaller than \\(U\\), at which point the probability is one. 2.4 Inverse Triangular CDF What if we already had a probability in mind but wanted to find the matching \\(x\\)? Well, in that case, we would need to calculate an inverse CDF. Given some probability \\(p\\), what \\(x\\) delimits \\(X\\) such that \\(p\\) is \\(P(X\\leq x)\\). Or in other words, find \\(g\\) such that: \\[ g(p) = F^{-1}(p) = F^{-1}(F(x)) = x \\] The proceure for finding the inverse of an equation of a parabola is very straight forward. The following is the inverse CDF of the triangular distribution. \\[ F^{-1}(p) = \\begin{cases} L + \\sqrt{(M-L)(U-L)p} \\quad&amp; (0 \\leq p &lt; \\frac{M-L}{U-L})\\\\ U - \\sqrt{(U-L)(U-M)(1-p)} \\quad&amp; (1 \\geq p \\geq \\frac{M-L}{U-L})\\\\ \\end{cases} \\] No plots for this one considering how it just mirrors the regular CDF over the \\(y=x\\) line. inverse.cumulative.triangular.distribution &lt;- function(p, L, U, M) { if (p &lt; (M - L) / (U - L)) { result &lt;- L + sqrt(max(0, (M - L) * (U - L) * p)) } else if (p &gt;= (M - L) / (U - L)) { result &lt;- U - sqrt(max(0, (U - L) * (U - M) * (1 - p))) } return(result) } Notice how we artificially coerce anything within the square root to be positive, with max(0, (M - L) * (U - L) * p) for example. We do this because small rounding errors can cause issues by approximating positive values close to cero or exactly cero to a negative number whereas the square root operator is only defined for positive real numbers (Ignore complex and imaginary numbers for now). 2.5 Measures of Central Tendency and Spread These descriptive statistics can easily be derived from the PDF and CDF. We’ll spare you the math, but keep the following in mind for their implementation in R. 2.5.1 Mean The expected value of a random variable \\(X\\). \\[ E(X) = \\mu = \\int_{-\\infty}^{\\infty}xf(x)dx = \\int_{L}^{U}xf(x)dx = \\frac{L+U+M}{3} \\] 2.5.2 Median Value \\(x\\) such that the probability that a random variable \\(X\\) be smaller is 0.5. \\[ \\text{Median(X)} = F^{-1}(0.5) = \\begin{cases} L + \\sqrt{\\frac{(U-L)(M-L)}{2}} \\quad&amp; (M \\geq \\frac{L+U}{2})\\\\ U - \\sqrt{\\frac{(U-L)(U-M)}{2}} \\quad&amp; (M \\leq \\frac{L+U}{2})\\\\ \\end{cases} \\] 2.5.3 Mode Value of a random variable \\(X\\) for which \\(f(x)\\) is at its maximum. \\[ \\text{Mode(X)} = M \\] 2.5.4 Variance Measure of spread of the distribution with respect to the mean. \\[ \\text{Var(X)} = \\sigma^{2} = \\int_{-\\infty}^{\\infty}x^{2}f(x)dx - \\mu^{2} = \\int_{L}^{U}x^{2}f(x)dx - \\mu^{2} = \\frac{L^{2} + U^{2} + M^{2} - LU - LM - UM}{18} \\] 2.6 An Object to Hold These Properties Knowing how to compute these quintessential properties of the trinagular distribution, it would make sense to build them into an object to be called on demand. Luckily, all we need is a constructor function that implements these procedures and computations and returns them in a variable that can hold multiple items of different class (a list). Consider the following constructor function that, when called, stores all explored functions and values into a list and returns it. ## Returns a function that returns a list with each of its elements defined as functions or vectors of one ## element that describe aspects of a triangular distribution ## (pdf, cdf, inverse cdf, mean, median, mode, upper bound, lower bound, variance) generate.triangular &lt;- function(L, U, M) { ## Create a function that returns the pdf of the triangular, given some x. pdf &lt;- function(x) { if (x &lt; L) { result &lt;- 0 } else if (x &lt; M) { result &lt;- 2 * (x - L) / ((U - L) * (M - L)) } else if (x == M) { result &lt;- 2 / (U - L) } else if (x &lt;= U) { result &lt;- 2 * (U - x) / ((U - L) * (U - M)) } else if (U &lt; x) { result &lt;- 0 } return(result) } ## Create a function that returns the cdf of the triangular, given some x. cdf &lt;- function(x) { if (x &lt;= L) { result &lt;- 0 } else if (x &lt;= M) { result &lt;- ((x - L) ^ 2) / ((U - L) * (M - L)) } else if (x &lt; U) { result &lt;- 1 - ((U - x) ^ 2) / ((U - L) * (U - M)) } else if (U &lt;= x) { result &lt;- 1 } return(result) } ## Create a function that returns the inverse cdf of the triangular, given some probability p. inverse.cdf &lt;- function(p) { if (p &lt; (M - L) / (U - L)) { result &lt;- L + sqrt(max(0, (M - L) * (U - L) * p)) } else if (p &gt;= (M - L) / (U - L)) { result &lt;- U - sqrt(max(0, (U - L) * (U - M) * (1 - p))) } return(result) } ## Create a vector of length 1 that describes the mean of the distribution tri.mean &lt;- (L + U + M) / 3 ## Create a vector of length 1 that describes the median of the distribution tri.median &lt;- inverse.cdf(0.5) ## Create a vector of length 1 that describes the mode of the distribution tri.mode &lt;- M ## Create a vector of length 1 that describes the upper bound of the distribution&#39;s domain tri.upper &lt;- U ## Create a vector of length 1 that describes the lower bound of the distribution&#39;s domain tri.lower &lt;- L ## Create a vector of length 1 that describes the variance of the distribution tri.var &lt;- ((L ^ 2) + (U ^ 2) + (M ^ 2) - L * U - L * M - U * M) / 18 ## Build the list and return it. This list contains all major properties of the triangular distribution return( list( pdf = pdf, cdf = cdf, inverse.cdf = inverse.cdf, tri.mean = tri.mean, tri.median = tri.median, tri.mode = tri.mode, tri.upper = tri.upper, tri.lower = tri.lower, tri.var = tri.var ) ) } "],["truncated-triangular-distribution.html", "3 Truncated Triangular Distribution 3.1 Truncated Distribution 3.2 Truncated Triangular PDF 3.3 Truncated Triangular CDF 3.4 Inverse Truncated Triangular CDF 3.5 Measures of Central Tendency and Spread 3.6 An Object to Hold These Properties", " 3 Truncated Triangular Distribution 3.1 Truncated Distribution A truncated distribution, simply put, is a distribution derived from another such that it’s domain is restricted to some interval \\((a,b]\\). The function itself might not change but because we require the area under the PDF to be equal to 1, a transformation is due. One of the strengths of this distribution lies in the fact that most of it properties can be calculated from methods already implemented in the underlying distribution, meaning that the functions and values need not be derived analytically and so it’s implementation is easily generalized. 3.2 Truncated Triangular PDF Since we’re handling more than one distribution, let’s distinguish them symbolically. Let \\(Y\\sim f(y) = Triangular(L, U, M)\\) and \\(X\\sim f(x|a &lt; X \\leq b) = h(x)\\) The truncated distribution has the following PDF, regardless of the underlying distribution. \\[ h(x)= \\begin{cases} \\frac{f(x)}{F(b)-F(a)}\\quad&amp;(a&lt; x\\leq b)\\\\ 0\\quad&amp;(x\\ \\notin\\ ]a,b])\\\\ \\end{cases} \\] Multiplying the original distribution’s PDF by a factor of \\(\\frac{1}{F(b)-F(a)}\\) just scales it so the area removed by truncating the domain gets compensated for. Because we can already account for \\(f(x)\\) and \\(F(x)\\) in our original implementation of the triangular distribution, there is no need to analyticaly derive the new PDF. Let’s store an instance of the triangular distribution list in a variable and call it’s functions and values on demand. ## Create a list that contains the major properties of a triangular distribution with L = 2, U = 9, and M = 7 triangular.distribution &lt;- generate.triangular(L = 2, U = 9, M = 7) We will use this triangular as the distribution to truncate truncated.distribution &lt;- function(x, a, b) { if (a &lt; x &amp; x &lt;= b) { pdf.g &lt;- triangular.distribution$pdf cumul.F &lt;- triangular.distribution$cdf result &lt;- pdf.g(x) / (cumul.F(b) - cumul.F(a)) return(result) } else { result &lt;- 0 return(result) } } This function takes some x and evaluates the truncated triangular PDF defined in the triangular.distribution variable. truncated.distribution.vectorized &lt;- function(x, ...) { sapply(x, truncated.distribution, ...) } Because of the nature of the plot.function() method, we must make our function compatible with vectors, meaning that passing a vector as its x parameter would apply the function to every element in it. Notice the .... This just means that any subsequent parameters get passed to the underlying truncated.distribution() function. plot.function( function(x) {truncated.distribution.vectorized(x, 2, 9)}, from = 2, to = 9, main = &quot;Truncated Triangular Distributions&quot;, ylab = &quot;f(x)&quot;, ylim = c(0, 0.5) ) ## Additional plots get included in the first rather than into a new canvas ## when the `add` parameter is set to TRUE. plot.function( function(x) {truncated.distribution.vectorized(x, 3, 8)}, from = 2, to = 9, col = &quot;red&quot;, add = TRUE ) plot.function( function(x) {truncated.distribution.vectorized(x, 4, 7)}, from = 2, to = 9, col = &quot;blue&quot;, add = TRUE ) ## Let&#39;s also include a legend so we can distinguish all three distributions. legend( x = 2, y = 0.5, legend = c(&quot;f(x|2 &lt; x &lt;= 9)&quot;, &quot;f(x|3 &lt; x &lt;= 8)&quot;, &quot;f(x|4 &lt; x &lt;= 7)&quot;), col = c(&quot;black&quot;, &quot;red&quot;, &quot;blue&quot;), lty = 1 ) Notice how our distributions get scaled up further as the new domain becomes narrower. The black distribution faces no changes because cutting it’s domain to \\(a=2\\) and \\(b=9\\) makes no difference, and so the triangular distribution remains. 3.3 Truncated Triangular CDF The CDF is quite straight forward to understand. Because the PDF of the runcated triangular is the same as the original only restricted in its domain and scaled by a constant factor of \\(\\frac{1}{F(b)-F(a)}\\), all we really need to falculate \\(H(x)\\) is to calculate \\(F(x)\\), subtract the portion now unaccounted for by the restrictions to the domain (\\(F(a)\\)), and scale by the same factor as the PDF. \\[ H(x) = \\begin{cases} 0 \\quad&amp; x\\leq a\\\\ \\frac{F(x)-F(a)}{F(b)-F(a)} \\quad&amp; a &lt; x \\leq b\\\\ 1 \\quad&amp; b &lt; x \\end{cases} \\] Again, the implementation of the triangular distribution already considers a function to calculate the triangular CDF, meaning that there is no need to analyticaly derive the equation. It’s good enough to call the CDF directly. cumulative.truncated.distribution &lt;- function(x, a, b) { if (x &lt;= a) { result &lt;- 0 } else if (a &lt; x &amp; x &lt;= b) { result &lt;- (triangular.distribution$cdf(x) - triangular.distribution$cdf(a)) / (triangular.distribution$cdf(b) - triangular.distribution$cdf(a)) } else if (x &gt; b){ result &lt;- 1 } return(result) } cumulative.truncated.distribution.vectorized &lt;- function(x, ...) { sapply(x, cumulative.truncated.distribution, ...) } The code for the plots also shouldn’t change much. No change has been made to the parameters of each distribution. plot.function( function(x) {cumulative.truncated.distribution.vectorized(x, 2, 9)}, from = 0, to = 10, main = &quot;Cumulative Truncated Triangular Distributions&quot;, ylab = &quot;F(x)&quot;, ylim = c(0, 1) ) plot.function( function(x) {cumulative.truncated.distribution.vectorized(x, 3, 8)}, from = 0, to = 10, col = &quot;red&quot;, add = TRUE ) plot.function( function(x) {cumulative.truncated.distribution.vectorized(x, 4, 7)}, from = 0, to = 10, col = &quot;blue&quot;, add = TRUE ) legend( x = 0, y = 1, legend = c(&quot;F(x|2 &lt; x &lt;= 9)&quot;, &quot;F(x|3 &lt; x &lt;= 8)&quot;, &quot;F(x|4 &lt; x &lt;= 7)&quot;), col = c(&quot;black&quot;, &quot;red&quot;, &quot;blue&quot;), lty = 1 ) Notice how the cumulative distribution approaches one very quickly. This makes sense considering that, because of the bounds of the domain of the triangular distribution, \\(X\\) is guaranteed to be smaller than \\(U\\), at which point the probability is one. 3.4 Inverse Truncated Triangular CDF What if we already had a probability in mind but wanted to find the matching \\(x\\)? Well, in that case, we would need to calculate an inverse CDF. Given some probability \\(p\\), what \\(x\\) delimits \\(X\\) such that \\(p\\) is \\(P(X\\leq x)\\). Or in other words, find \\(g\\) such that: \\[ g(p) = F^{-1}(p) = F^{-1}(F(x)) = x \\] Explicitly, we really just need to solve for \\(x\\) in the following equation. \\[ H(x)=\\frac{F(x)-F(a)}{F(b)-F(a)}=p \\] The resulting expression will be in terms of a probability \\(p\\). \\[ H^{-1}(p) = F^{-1}\\left(p(F(b)-F(a)) + F(a)\\right) \\] Remember how our triangular.distribution object has cdf() and inverse.cdf() methods, meaning the inverse cdf of the truncated triangular distribution can also be computed from the implementation of the base distribution. inverse.cumulative.truncated.distribution &lt;- function(p, a, b) { result &lt;- tringular.distribution$inverse.cdf( p * (tringular.distribution$cdf(b) - tringular.distribution$cdf(a)) + tringular.distribution$cdf(a) ) return(result) } No plots for this one considering how it just mirrors the regular CDF over the \\(y=x\\) line. Do consider, this distribution is only defined for \\(p\\in[0,1]\\). Some error handling could benefit your code’s reliability. 3.5 Measures of Central Tendency and Spread We do come across a challenge when trying to figure out expressions for these statistics. First we must derive their expression analytically because they can’t be expressed just in terms of what we have already implemented in the triangular distribution (We must evaluate definite integrals); second, because these definite integral explicitly make use of the underlying triangular distribution, they can’t be generalised to the whole family of truncated distributions; and finally, the triangular distribution is a piecewise function, meaning the procedure to derive an expression must be done on a case by case basis. 3.5.1 Mean The expected value of a random variable \\(X\\). \\[ E(X) = \\int_{-\\infty}^{\\infty}xh(x)dx = \\int_{a}^{b}x\\cdot\\frac{f(x)}{F(b)-F(a)}dx= \\frac{\\int_{a}^{b}xf(x)dx}{F(b)-F(a)} \\] Case 1 (\\(L \\leq a \\leq b &lt; M\\)): \\[ E(X)=\\frac{\\int_{a}^{b} x \\cdot \\frac{2(x-L)}{(U-L)(M-L)} dx}{F(b)-F(a)} \\] \\[ = \\frac{\\frac{2\\left( b^{3} - a^{3} - 3L\\left( \\frac{b^{2}}{2} - \\frac{a^{2}}{2} \\right) \\right)}{3(U-L)(M-L)}}{F(b)-F(a)} \\] Case 2 (\\(L \\leq a &lt; M \\leq b \\leq U\\)): \\[ E(X)=\\frac{\\int_{a}^{M} x \\cdot \\frac{2(x-L)}{(U-L)(M-L)} dx + \\int_{M}^{b} x \\cdot \\frac{2(U-x)}{(U-L)(U-M)} dx}{F(b)-F(a)} \\] \\[ = \\frac{\\frac{-M^3U-2a^3U+3La^2U+3Mb^2U-3Lb^2U+LM^3+2Ma^3-3LMa^2-2Mb^3+2Lb^3}{3(U-L)(M-L)(U-M)}}{F(b)-F(a)} \\] Case 3 (\\(M \\leq a \\leq b \\leq U\\)): \\[ E(X)=\\frac{\\int_{M}^{b} x \\cdot \\frac{2(U-x)}{(U-L)(U-M)} dx}{F(b)-F(a)} \\] \\[ = \\frac{\\frac{3b^2U-3M^2U-2b^3+2M^3}{3\\left(-L+U\\right)\\left(U-M\\right)}}{F(b)-F(a)} \\] 3.5.2 Median Value \\(x\\) such that the probability that a random variable \\(X\\) be smaller is 0.5. \\[ \\text{Median(X)} = H^{-1}(0.5) \\] This one is straight forward. We already implemented the inverse CDF. 3.5.3 Mode Value of a random variable \\(X\\) for which \\(f(x)\\) is at its maximum. Once again, we rely on the cases and calculate the mode according to where the bounds of the truncated fall. \\[ \\text{Mode(X)} = \\begin{cases} b \\quad&amp; (L \\leq a \\leq b &lt; M)\\\\ M \\quad&amp; (L \\leq a &lt; M \\leq b \\leq U)\\\\ a \\quad&amp; (M \\leq a \\leq b \\leq U) \\end{cases} \\] 3.5.4 Variance Measure of spread of the distribution with respect to the mean. \\[ \\text{Var(X)} = \\int_{-\\infty}^{\\infty}x^{2}h(x)dx - E(X)^{2} = \\int_{a}^{b}x^{2}\\cdot\\frac{f(x)}{F(b)-F(a)}dx - E(X)^{2} = \\frac{\\int_{a}^{b}x^{2}f(x)dx}{F(b)-F(a)} - E(X)^{2} \\] Case 1 (\\(L \\leq a \\leq b &lt; M\\)): \\[ \\text{Var}(X)=\\frac{\\int_{a}^{b} x^{2} \\cdot \\frac{2(x-L)}{(U-L)(M-L)} dx}{F(b)-F(a)}-E(X)^{2} \\] \\[ = \\frac{\\frac{-4L\\left(\\frac{b^3}{3}-\\frac{a^3}{3}\\right)+b^4-a^4}{2\\left(U-L\\right)\\left(M-L\\right)}}{F(b)-F(a)}-E(X)^{2} \\] Case 2 (\\(L \\leq a &lt; M \\leq b \\leq U\\)): \\[ \\text{Var}(X)=\\frac{\\int_{a}^{M} x^{2} \\cdot \\frac{2(x-L)}{(U-L)(M-L)} dx + \\int_{M}^{b} x^{2} \\cdot \\frac{2(U-x)}{(U-L)(U-M)} dx}{F(b)-F(a)}-E(X)^{2} \\] \\[ = \\frac{\\frac{-M^4U-3a^4U+4La^3U+4Mb^3U-4Lb^3U+LM^4+3Ma^4-4LMa^3-3Mb^4+3Lb^4}{6\\left(U-L\\right)\\left(M-L\\right)\\left(U-M\\right)}}{F(b)-F(a)}-E(X)^{2} \\] Case 3 (\\(M \\leq a \\leq b \\leq U\\)): \\[ \\text{Var}(X)=\\frac{\\int_{M}^{b} x^{2} \\cdot \\frac{2(U-x)}{(U-L)(U-M)} dx}{F(b)-F(a)}-E(X)^{2} \\] \\[ = \\frac{\\frac{4b^3U-4M^3U-3b^4+3M^4}{6\\left(U-L\\right)\\left(U-M\\right)}}{F(b)-F(a)}-E(X)^{2} \\] 3.6 An Object to Hold These Properties Knowing how to compute these quintessential properties of the truncated trinagular distribution, it would make sense to build them into an object to be called on demand. Luckily, all we need is a constructor function that implements these procedures and computations and returns them in a variable that can hold multiple items of different class (a list). Consider the following constructor function that, when called, stores all explored functions and values into a list and returns it. Notice how this function takes a triangular distribution object for its third parameter. The reason for this is self evident but if you’ve skipped up until this point, know that the truncated distribution is the transformation of some other distribution. ## Returns a function that returns a list with each of its elements defined as functions or vectors of one ## element that describe aspects of a truncated triangular distribution ## (pdf, cdf, inverse cdf, mean, median, mode, upper bound, lower bound, variance). generate.truncated.triangular &lt;- function(a, b, orig.tri.dist) { ## Original parameters of the triangular distribution M &lt;- orig.tri.dist$tri.mode L &lt;- orig.tri.dist$tri.lower U &lt;- orig.tri.dist$tri.upper ## Throw an error if the new bounds do not fall witin the old bounds of the triangular pdf. if (a &lt; L | b &gt; U) { stop(&quot;The new bounds of the pdf do not fall within the original range&quot;) } ## Create a function that returns the pdf of the truncated triangular, given some x. pdf &lt;- function(x) { if (a &lt; x &amp; x &lt;= b) { pdf.g &lt;- orig.tri.dist$pdf cumul.F &lt;- orig.tri.dist$cdf result &lt;- pdf.g(x) / (cumul.F(b) - cumul.F(a)) return(result) } else { result &lt;- 0 return(result) } } ## Create a function that returns the cdf of the truncated triangular, given some x. cdf &lt;- function(x) { cumul.F &lt;- orig.tri.dist$cdf if (x &lt;= a) { result &lt;- 0 } else if (a &lt; x &amp; x &lt;= b) { result &lt;- (cumul.F(x) - cumul.F(a)) / (cumul.F(b) - cumul.F(a)) } else if (b &lt; x) { result &lt;- 1 } return(result) } ## Create a function that returns the inverse cdf of the truncated triangular, given some probability p. inverse.cdf &lt;- function(p) { result &lt;- orig.tri.dist$inverse.cdf(p * (orig.tri.dist$cdf(b) - orig.tri.dist$cdf(a)) + orig.tri.dist$cdf(a)) return(result) } ## Create a vector of length 1 that describes the mean of the distribution trun.tri.mean &lt;- if (a &lt;= b &amp; b &lt; M) { result.numerator &lt;- (2 * (-3 * L * ((b ^ 2) / 2 - (a ^ 2) / 2) + b ^ 3 - a ^ 3)) / (3 * (U - L) * (M - L)) result.denominator &lt;- orig.tri.dist$cdf(b) - orig.tri.dist$cdf(a) result.numerator / result.denominator } else if (a &lt; M &amp; b &gt;= M) { result.numerator &lt;- ( -M ^ 3 * U - 2 * a ^ 3 * U + 3 * L * a ^ 2 * U + 3 * M * b ^ 2 * U - 3 * L * b ^ 2 * U + L * M ^ 3 + 2 * M * a ^ 3 - 3 * L * M * a ^ 2 - 2 * M * b ^ 3 + 2 * L * b ^ 3 ) / (3 * (U - L) * (M - L) * (U - M)) result.denominator &lt;- orig.tri.dist$cdf(b) - orig.tri.dist$cdf(a) result.numerator / result.denominator } else if (M &lt;= a &amp; a &lt;= b) { result.numerator &lt;- (3 * b ^ 2 * U - 3 * a ^ 2 * U - 2 * b ^ 3 + 2 * a ^ 3) / (3 * (U - L) * (U - M)) result.denominator &lt;- orig.tri.dist$cdf(b) - orig.tri.dist$cdf(a) result.numerator / result.denominator } ## Create a vector of length 1 that describes the median of the distribution trun.tri.median &lt;- inverse.cdf(0.5) ## Create a vector of length 1 that describes the mode of the distribution trun.tri.mode &lt;- if (a &lt;= b &amp; b &lt;= M) { b } else if (a &lt;= b &amp; b &gt;= M) { M } else if (a &gt;= M &amp; b &gt;= a) { a } ## Create a vector of length 1 that describes the upper bound of the distribution&#39;s domain trun.tri.upper &lt;- b ## Create a vector of length 1 that describes the lower bound of the distribution&#39;s domain trun.tri.lower &lt;- a ## Create a vector of length 1 that describes the variance of the distribution trun.tri.var &lt;- if (a &lt;= b &amp; b &lt; M) { result.numerator &lt;- (-4 * L * ((b ^ 3) / 3 - (a ^ 3) / 3) + b ^ 4 - a ^ 4) / (2 * (U - L) * (M - L)) result.denominator &lt;- orig.tri.dist$cdf(b) - orig.tri.dist$cdf(a) (result.numerator / result.denominator) - trun.tri.mean ^ 2 } else if (a &lt; M &amp; b &gt;= M) { result.numerator &lt;- ( -M ^ 4 * U - 3 * a ^ 4 * U + 4 * L * a ^ 3 * U + 4 * M * b ^ 3 * U - 4 * L * b ^ 3 * U + L * M ^ 4 + 3 * M * a ^ 4 - 4 * L * M * a ^ 3 - 3 * M * b ^ 4 + 3 * L * b ^ 4 ) / (6 * (U - L) * (M - L) * (U - M)) result.denominator &lt;- orig.tri.dist$cdf(b) - orig.tri.dist$cdf(a) (result.numerator / result.denominator) - trun.tri.mean ^ 2 } else if (M &lt;= a &amp; a &lt;= b) { result.numerator &lt;- (4 * (b ^ 3) * U - 4 * (a ^ 3) * U - 2 * b ^ 4 + 3 * a ^ 4) / (6 * (U - L) * (U - M)) result.denominator &lt;- orig.tri.dist$cdf(b) - orig.tri.dist$cdf(a) (result.numerator / result.denominator) - trun.tri.mean ^ 2 } ## Build the list and return it. This list contains all major properties of the truncated triangular distribution return( list( pdf = pdf, cdf = cdf, inverse.cdf = inverse.cdf, trun.tri.mean = trun.tri.mean, trun.tri.median = trun.tri.median, trun.tri.mode = trun.tri.mode, trun.tri.upper = trun.tri.upper, trun.tri.lower = trun.tri.lower, trun.tri.var = trun.tri.var ) ) } "],["simulation-and-validation-.html", "4 Simulation and Validation. 4.1 R Markdown 4.2 Including Plots", " 4 Simulation and Validation. So far we have designed two constructor functions, generate.triangular() and generate.truncated.triangular(), with which we may create triangular distributions and truncated triangular distributions respectively. We now may want to validate our implementation. An easy method to validate our functions that calculate descriptive statistics or the pdf is to use it as a means to generate a random sample 4.1 R Markdown This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see http://rmarkdown.rstudio.com. When you click the Knit button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this: summary(cars) ## speed dist ## Min. : 4.0 Min. : 2.00 ## 1st Qu.:12.0 1st Qu.: 26.00 ## Median :15.0 Median : 36.00 ## Mean :15.4 Mean : 42.98 ## 3rd Qu.:19.0 3rd Qu.: 56.00 ## Max. :25.0 Max. :120.00 4.2 Including Plots You can also embed plots, for example: Note that the echo = FALSE parameter was added to the code chunk to prevent printing of the R code that generated the plot. "]]
