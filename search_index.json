[["index.html", "Simulating the Truncated Triangular Distribution 1 Intro 1.1 Motivation 1.2 Your own flare 1.3 Project home 1.4 Disclaimer 1.5 Acknowledgments 1.6 Author 1.7 License", " Simulating the Truncated Triangular Distribution Alejandro Mantilla 2021-01-25 1 Intro 1.1 Motivation The triangular distribution is a thoroughly studied probability density function (PDF) that usually arises to describe the behavior of a real (\\(\\mathbb{R}\\)) random variable for which little information is available. The distribution is an easy fit for most practical scenarios and, as such, makes it extremely versatile as a means to model non-deterministic scenarios mathematically. To further aid our analysis, we consider the truncated distribution, a generic term that encompasses a transform of any given PDF such that it remains a PDF after restricting the function’s domain to an interval within. Our end goal is to perform a few analytical procedures to find parameterized expressions for a few major descriptive statistics and functions (such as the CDF) of both distributions and implement them in the R language. To show how one may realistically use these implementations we will explore a practical example wherein a triangular distribution and a corresponding truncated triangular distribution are constructed using our implementation and then used to generate random samples with Monte Carlo simulation. 1.2 Your own flare Those familiar with object-oriented programming might notice our approach takes after a few basic concepts such as constructor functions and composition. If this sounds interesting to you, I encourage you to add your own twist to this exercise and use classes instead of lists but know that it is not a must and we will be using only the most rudimentary features R has to offer. This implementation was designed with adaptability in mind, meaning that the same approach should also be compatible with other scripting languages such as Python or JavaScript. Plots aside, no external packages or libraries are required, though we use base R’s plot() family of functions which come pre-installed. 1.3 Project home All documents, markdown files, scripts, and project images are publicly available in this repository. 1.4 Disclaimer All errors are my own. All feedback is welcome. 1.5 Acknowledgments Special thanks to Alfaima Solano from Universidad de los Andes for their feedback on this project. 1.6 Author Alejandro Mantilla Data Scientist and Engineer Bogotá, Colombia 1.7 License Copyright (c) 2021 Alejandro Mantilla "],["triangular-distribution.html", "2 Triangular Distribution 2.1 Distributions 2.2 Triangular PDF 2.3 Triangular CDF 2.4 Inverse Triangular CDF 2.5 Measures of Central Tendency and Spread 2.6 An Object to Hold These Properties", " 2 Triangular Distribution 2.1 Distributions Probability density functions describe how likely it is for a continuous random variable \\(X\\) to fall within some region of its domain. For any single point the probability is cero but at intervals we can calculate the integral of the PDF and find the corresponding probability. Consider the following conventions: Let \\(X\\) be a random variable with distribution \\(f(x)\\) This way of defining random variables lets on some basic information about how it may behave but is lengthy and unnecessary. Let \\(X\\sim f(x)\\) Much better. Let \\(X\\sim f(x) = \\frac{e^{-\\frac{1}{2}\\left( \\frac{x-\\mu}{\\sigma}\\right)^{2}}}{\\sigma \\sqrt{2\\pi}}\\) A PDF will sometimes be defined for the entire real number line in a single expression like the ubiquitous normal distribution, while others require you to write piecewise functions such as the triangular distribution. Let \\(X\\sim Norm(\\mu, \\sigma^{2})\\) and \\(Y\\sim Triangular(L,U,M)\\) We use a shorthand notation for widely used distributions that would usually take too much effort to remember or write out. 2.2 Triangular PDF The triangular distribution specifically has the following PDF. \\[ f(x)= \\begin{cases} \\frac{2(x-L)}{(U-L)(M-L)}\\quad&amp;(L\\leq x&lt;M)\\\\ \\frac{2(U-x)}{(U-L)(U-M)}\\quad&amp;(M\\leq x\\leq U)\\\\ \\end{cases} \\] Though complicated at first sight, it really just describes two lines that form a triangle with the \\(x\\) axis. \\(L\\) and \\(U\\) stand for the lower and upper values that delimit the distribution and \\(M\\) is the mode. The function is explicit for when its value is different from cero, meaning we exclude the self-evident conditions for which it’s cero. Let’s start writing some code and see some plots of this distribution in action. triangular.distribution &lt;- function(x, L, U, M) { if (x &lt; L) { result &lt;- 0 } else if (x &lt; M) { result &lt;- 2 * (x - L) / ((U - L) * (M - L)) } else if (x == M) { result &lt;- 2 / (U - L) } else if (x &lt;= U) { result &lt;- 2 * (U - x) / ((U - L) * (U - M)) } else if (U &lt; x) { result &lt;- 0 } return(result) } This function takes some x and evaluates the triangular PDF defined by \\(L\\), \\(U\\), and \\(M\\) on it. triangular.distribution.vectorized &lt;- function(x, ...) { sapply(x, triangular.distribution, ...) } Because of the nature of the plot.function() method, we must make our function compatible with vectors, meaning that passing a vector as its x parameter would apply the function to every element in it. Notice the .... This just means that any subsequent parameters get passed to the underlying triangular.distribution() function. plot.function( function(x) {triangular.distribution.vectorized(x, 2, 9, 7)}, from = 2, to = 9, main = &quot;Triangular Distributions&quot;, ylab = &quot;f(x)&quot;, ylim = c(0, 0.5) ) ## Additional plots get included in the first rather than into a new canvas ## when the `add` parameter is set to TRUE. plot.function( function(x) {triangular.distribution.vectorized(x, 3, 8, 7)}, from = 2, to = 9, col = &quot;red&quot;, add = TRUE ) plot.function( function(x) {triangular.distribution.vectorized(x, 2, 8.5, 2)}, from = 1.9999999, to = 9, col = &quot;blue&quot;, add = TRUE ) ## Let&#39;s also include a legend so we can distinguish all three distributions. legend( x = 2, y = 0.5, legend = c(&quot;Triang(2, 9, 7)&quot;, &quot;Triang(3, 8, 7)&quot;, &quot;Triang(2, 8.5, 2)&quot;), col = c(&quot;black&quot;, &quot;red&quot;, &quot;blue&quot;), lty = 1 ) Notice how our distributions take the shape of a triangle when \\(x\\) falls within the interval of \\(L\\) and \\(U\\) but is cero everywhere else. 2.3 Triangular CDF The PDF alone won’t do us much good, considering how we still need to calculate probabilities somehow (remember, at any point the probability of a continuous random variable is 0). Let us define the CDF as the probability that our random variable \\(X\\) is smaller than some value \\(x\\). Or in mathematical notation: \\[ F(x) = P\\left( X \\leq x \\right) = \\int_{-\\infty}^{x}f(t)dt = \\int_{L}^{x}f(t)dt \\] The PDF is defined by two continuous lines and so it follows that we could compute the integral from negative infinity to some \\(x\\) to be: \\[ F(x)= \\begin{cases} \\frac{(x-L)^{2}}{(U-L)(M-L)}\\quad&amp;(L\\leq x&lt;M)\\\\ 1 - \\frac{(U-x)^{2}}{(U-L)(U-M)}\\quad&amp;(M\\leq x\\leq U)\\\\ 1 \\quad&amp; (U &lt; x)\\\\ \\end{cases} \\] We can now implement this in R in similar fashion to our PDF. cumulative.triangular.distribution &lt;- function(x, L, U, M) { if (x &lt; L) { result &lt;- 0 } else if (x &lt;= M) { result &lt;- (x - L) ^ 2 / ((U - L) * (M - L)) } else if (x &lt; U) { result &lt;- 1 - (U - x) ^ 2 / ((U - L) * (U - M)) } else if (U &lt;= x) { result &lt;- 1 } return(result) } cumulative.triangular.distribution.vectorized &lt;- function(x, ...) { sapply(x, cumulative.triangular.distribution, ...) } The code for the plots also shouldn’t change much. No change has been made to the parameters of each distribution. plot.function( function(x) {cumulative.triangular.distribution.vectorized(x, 2, 9, 7)}, from = 0, to = 10, main = &quot;Cumulative Triangular Distributions&quot;, ylab = &quot;F(x)&quot;, ylim = c(0, 1) ) plot.function( function(x) {cumulative.triangular.distribution.vectorized(x, 3, 8, 7)}, from = 0, to = 10, col = &quot;red&quot;, add = TRUE ) plot.function( function(x) {cumulative.triangular.distribution.vectorized(x, 2, 8.5, 2)}, from = 0, to = 10, col = &quot;blue&quot;, add = TRUE ) legend( x = 0, y = 1, legend = c(&quot;F(x)|f(x)=Triang(2, 9, 7)&quot;, &quot;F(x)|f(x)=Triang(3, 8, 7)&quot;, &quot;F(x)|f(x)=Triang(2, 8.5, 2)&quot;), col = c(&quot;black&quot;, &quot;red&quot;, &quot;blue&quot;), lty = 1 ) Notice how the cumulative distribution approaches and becomes one very quickly. This makes sense considering that, because of the bounds of the domain of the triangular distribution, \\(X\\) is guaranteed to be smaller than \\(U\\), at which point the probability is one. 2.4 Inverse Triangular CDF What if we already had a probability in mind but wanted to find the matching \\(x\\)? Well, in that case, we would need to calculate an inverse CDF. Given some probability \\(p\\), what \\(x\\) delimits \\(X\\) such that \\(p\\) is \\(P(X\\leq x)\\). Or in other words, find \\(g\\) such that: \\[ g(p) = F^{-1}(p) = F^{-1}(F(x)) = x \\] The proceure for finding the inverse of an equation of a parabola is very straight forward. The following is the inverse CDF of the triangular distribution. \\[ F^{-1}(p) = \\begin{cases} L + \\sqrt{(M-L)(U-L)p} \\quad&amp; (0 \\leq p &lt; \\frac{M-L}{U-L})\\\\ U - \\sqrt{(U-L)(U-M)(1-p)} \\quad&amp; (1 \\geq p \\geq \\frac{M-L}{U-L})\\\\ \\end{cases} \\] No plots for this one considering how it just mirrors the regular CDF over the \\(y=x\\) line. inverse.cumulative.triangular.distribution &lt;- function(p, L, U, M) { if (p &lt; (M - L) / (U - L)) { result &lt;- L + sqrt(max(0, (M - L) * (U - L) * p)) } else if (p &gt;= (M - L) / (U - L)) { result &lt;- U - sqrt(max(0, (U - L) * (U - M) * (1 - p))) } return(result) } Notice how we artificially coerce anything within the square root to be positive, with max(0, (M - L) * (U - L) * p) for example. We do this because small rounding errors can cause issues by approximating positive values close to cero or exactly cero to a negative number whereas the square root operator is only defined for positive real numbers (Ignore complex and imaginary numbers for now). 2.5 Measures of Central Tendency and Spread These descriptive statistics can easily be derived from the PDF and CDF. We’ll spare you the math, but keep the following in mind for their implementation in R. 2.5.1 Mean The expected value of a random variable \\(X\\). \\[ E(X) = \\mu = \\int_{-\\infty}^{\\infty}xf(x)dx = \\int_{L}^{U}xf(x)dx = \\frac{L+U+M}{3} \\] 2.5.2 Median Value \\(x\\) such that the probability that a random variable \\(X\\) be smaller is 0.5. \\[ \\text{Median(X)} = F^{-1}(0.5) = \\begin{cases} L + \\sqrt{\\frac{(U-L)(M-L)}{2}} \\quad&amp; (M \\geq \\frac{L+U}{2})\\\\ U - \\sqrt{\\frac{(U-L)(U-M)}{2}} \\quad&amp; (M \\leq \\frac{L+U}{2})\\\\ \\end{cases} \\] 2.5.3 Mode Value of a random variable \\(X\\) for which \\(f(x)\\) is at its maximum. \\[ \\text{Mode(X)} = M \\] 2.5.4 Variance Measure of spread of the distribution with respect to the mean. \\[ \\text{Var(X)} = \\sigma^{2} = \\int_{-\\infty}^{\\infty}x^{2}f(x)dx - \\mu^{2} = \\int_{L}^{U}x^{2}f(x)dx - \\mu^{2} = \\frac{L^{2} + U^{2} + M^{2} - LU - LM - UM}{18} \\] 2.6 An Object to Hold These Properties Knowing how to compute these quintessential properties of the trinagular distribution, it would make sense to build them into an object to be called on demand. Luckily, all we need is a constructor function that implements these procedures and computations and returns them in a variable that can hold multiple items of different class (a list). Consider the following constructor function that, when called, stores all explored functions and values into a list and returns it. ## Returns a function that returns a list with each of its elements defined as functions or vectors of one ## element that describe aspects of a triangular distribution ## (pdf, cdf, inverse cdf, mean, median, mode, upper bound, lower bound, variance) generate.triangular &lt;- function(L, U, M) { ## Create a function that returns the pdf of the triangular, given some x. pdf &lt;- function(x) { if (x &lt; L) { result &lt;- 0 } else if (x &lt; M) { result &lt;- 2 * (x - L) / ((U - L) * (M - L)) } else if (x == M) { result &lt;- 2 / (U - L) } else if (x &lt;= U) { result &lt;- 2 * (U - x) / ((U - L) * (U - M)) } else if (U &lt; x) { result &lt;- 0 } return(result) } ## Create a function that returns the cdf of the triangular, given some x. cdf &lt;- function(x) { if (x &lt;= L) { result &lt;- 0 } else if (x &lt;= M) { result &lt;- ((x - L) ^ 2) / ((U - L) * (M - L)) } else if (x &lt; U) { result &lt;- 1 - ((U - x) ^ 2) / ((U - L) * (U - M)) } else if (U &lt;= x) { result &lt;- 1 } return(result) } ## Create a function that returns the inverse cdf of the triangular, given some probability p. inverse.cdf &lt;- function(p) { if (p &lt; (M - L) / (U - L)) { result &lt;- L + sqrt(max(0, (M - L) * (U - L) * p)) } else if (p &gt;= (M - L) / (U - L)) { result &lt;- U - sqrt(max(0, (U - L) * (U - M) * (1 - p))) } return(result) } ## Create a vector of length 1 that describes the mean of the distribution tri.mean &lt;- (L + U + M) / 3 ## Create a vector of length 1 that describes the median of the distribution tri.median &lt;- inverse.cdf(0.5) ## Create a vector of length 1 that describes the mode of the distribution tri.mode &lt;- M ## Create a vector of length 1 that describes the upper bound of the distribution&#39;s domain tri.upper &lt;- U ## Create a vector of length 1 that describes the lower bound of the distribution&#39;s domain tri.lower &lt;- L ## Create a vector of length 1 that describes the variance of the distribution tri.var &lt;- ((L ^ 2) + (U ^ 2) + (M ^ 2) - L * U - L * M - U * M) / 18 ## Build the list and return it. This list contains all major properties of the triangular distribution return( list( pdf = pdf, cdf = cdf, inverse.cdf = inverse.cdf, tri.mean = tri.mean, tri.median = tri.median, tri.mode = tri.mode, tri.upper = tri.upper, tri.lower = tri.lower, tri.var = tri.var ) ) } "],["truncated-triangular-distribution.html", "3 Truncated Triangular Distribution 3.1 Truncated Distribution 3.2 Truncated Triangular PDF 3.3 Truncated Triangular CDF 3.4 Inverse Truncated Triangular CDF 3.5 Measures of Central Tendency and Spread 3.6 An Object to Hold These Properties", " 3 Truncated Triangular Distribution 3.1 Truncated Distribution A truncated distribution, simply put, is a distribution derived from another such that it’s domain is restricted to some interval \\(]a,b]\\). The function itself might not change but because we require the area under the PDF to be equal to 1, a transformation is due. One of the strengths of this distribution lies in the fact that most of it properties can be calculated from methods already implemented in the underlying distribution, meaning that the functions and values need not be derived analytically and so it’s implementation is easily generalized. 3.2 Truncated Triangular PDF Since we’re handling more than one distribution, let’s distinguish them symbolically. Let \\(Y\\sim f(y) = Triangular(L, U, M)\\) and \\(X\\sim f(x|a &lt; X \\leq b) = h(x)\\) The truncated distribution has the following PDF, regardless of the underlying distribution. \\[ h(x)= \\begin{cases} \\frac{f(x)}{F(b)-F(a)}\\quad&amp;(a&lt; x\\leq b)\\\\ 0\\quad&amp;(x\\ \\notin\\ ]a,b])\\\\ \\end{cases} \\] Multiplying the original distribution’s PDF by a factor of \\(\\frac{1}{F(b)-F(a)}\\) just scales it so the area removed by truncating the domain gets compensated for. Because we can already account for \\(f(x)\\) and \\(F(x)\\) in our original implementation of the triangular distribution, there is no need to analyticaly derive the new PDF. Let’s store an instance of the triangular distribution list in a variable and call it’s functions and values on demand. ## Create a list that contains the major properties of a triangular distribution with L = 2, U = 9, and M = 7 triangular.distribution &lt;- generate.triangular(L = 2, U = 9, M = 7) We will use this triangular as the distribution to truncate truncated.distribution &lt;- function(x, a, b) { if (a &lt; x &amp; x &lt;= b) { pdf.g &lt;- triangular.distribution$pdf cumul.F &lt;- triangular.distribution$cdf result &lt;- pdf.g(x) / (cumul.F(b) - cumul.F(a)) return(result) } else { result &lt;- 0 return(result) } } This function takes some x and evaluates the truncated triangular PDF defined in the triangular.distribution variable. truncated.distribution.vectorized &lt;- function(x, ...) { sapply(x, truncated.distribution, ...) } Because of the nature of the plot.function() method, we must make our function compatible with vectors, meaning that passing a vector as its x parameter would apply the function to every element in it. Notice the .... This just means that any subsequent parameters get passed to the underlying truncated.distribution() function. plot.function( function(x) {truncated.distribution.vectorized(x, 2, 9)}, from = 2, to = 9, main = &quot;Truncated Triangular Distributions&quot;, ylab = &quot;f(x)&quot;, ylim = c(0, 0.5) ) ## Additional plots get included in the first rather than into a new canvas ## when the `add` parameter is set to TRUE. plot.function( function(x) {truncated.distribution.vectorized(x, 3, 8)}, from = 2, to = 9, col = &quot;red&quot;, add = TRUE ) plot.function( function(x) {truncated.distribution.vectorized(x, 4, 7)}, from = 2, to = 9, col = &quot;blue&quot;, add = TRUE ) ## Let&#39;s also include a legend so we can distinguish all three distributions. legend( x = 2, y = 0.5, legend = c(&quot;f(x|2 &lt; x &lt;= 9)&quot;, &quot;f(x|3 &lt; x &lt;= 8)&quot;, &quot;f(x|4 &lt; x &lt;= 7)&quot;), col = c(&quot;black&quot;, &quot;red&quot;, &quot;blue&quot;), lty = 1 ) Notice how our distributions get scaled up further as the new domain becomes narrower. The black distribution faces no changes because cutting it’s domain to \\(a=2\\) and \\(b=9\\) makes no difference, and so the triangular distribution remains. 3.3 Truncated Triangular CDF The CDF is quite straight forward to understand. Because the PDF of the runcated triangular is the same as the original only restricted in its domain and scaled by a constant factor of \\(\\frac{1}{F(b)-F(a)}\\), all we really need to falculate \\(H(x)\\) is to calculate \\(F(x)\\), subtract the portion now unaccounted for by the restrictions to the domain (\\(F(a)\\)), and scale by the same factor as the PDF. \\[ H(x) = \\begin{cases} 0 \\quad&amp; x\\leq a\\\\ \\frac{F(x)-F(a)}{F(b)-F(a)} \\quad&amp; a &lt; x \\leq b\\\\ 1 \\quad&amp; b &lt; x \\end{cases} \\] Again, the implementation of the triangular distribution already considers a function to calculate the triangular CDF, meaning that there is no need to analyticaly derive the equation. It’s good enough to call the CDF directly. cumulative.truncated.distribution &lt;- function(x, a, b) { if (x &lt;= a) { result &lt;- 0 } else if (a &lt; x &amp; x &lt;= b) { result &lt;- (triangular.distribution$cdf(x) - triangular.distribution$cdf(a)) / (triangular.distribution$cdf(b) - triangular.distribution$cdf(a)) } else if (x &gt; b){ result &lt;- 1 } return(result) } cumulative.truncated.distribution.vectorized &lt;- function(x, ...) { sapply(x, cumulative.truncated.distribution, ...) } The code for the plots also shouldn’t change much. No change has been made to the parameters of each distribution. plot.function( function(x) {cumulative.truncated.distribution.vectorized(x, 2, 9)}, from = 0, to = 10, main = &quot;Cumulative Truncated Triangular Distributions&quot;, ylab = &quot;F(x)&quot;, ylim = c(0, 1) ) plot.function( function(x) {cumulative.truncated.distribution.vectorized(x, 3, 8)}, from = 0, to = 10, col = &quot;red&quot;, add = TRUE ) plot.function( function(x) {cumulative.truncated.distribution.vectorized(x, 4, 7)}, from = 0, to = 10, col = &quot;blue&quot;, add = TRUE ) legend( x = 0, y = 1, legend = c(&quot;F(x|2 &lt; x &lt;= 9)&quot;, &quot;F(x|3 &lt; x &lt;= 8)&quot;, &quot;F(x|4 &lt; x &lt;= 7)&quot;), col = c(&quot;black&quot;, &quot;red&quot;, &quot;blue&quot;), lty = 1 ) Notice how the cumulative distribution approaches one very quickly. This makes sense considering that, because of the bounds of the domain of the triangular distribution, \\(X\\) is guaranteed to be smaller than \\(U\\), at which point the probability is one. 3.4 Inverse Truncated Triangular CDF What if we already had a probability in mind but wanted to find the matching \\(x\\)? Well, in that case, we would need to calculate an inverse CDF. Given some probability \\(p\\), what \\(x\\) delimits \\(X\\) such that \\(p\\) is \\(P(X\\leq x)\\). Or in other words, find \\(g\\) such that: \\[ g(p) = H^{-1}(p) = H^{-1}(H(x)) = x \\] Explicitly, we really just need to solve for \\(x\\) in the following equation. \\[ H(x)=\\frac{F(x)-F(a)}{F(b)-F(a)}=p \\] The resulting expression will be in terms of a probability \\(p\\). \\[ H^{-1}(p) = F^{-1}\\left(p(F(b)-F(a)) + F(a)\\right) \\] Remember how our triangular.distribution object has cdf() and inverse.cdf() methods, meaning the inverse cdf of the truncated triangular distribution can also be computed from the implementation of the base distribution. inverse.cumulative.truncated.distribution &lt;- function(p, a, b) { result &lt;- tringular.distribution$inverse.cdf( p * (tringular.distribution$cdf(b) - tringular.distribution$cdf(a)) + tringular.distribution$cdf(a) ) return(result) } No plots for this one considering how it just mirrors the regular CDF over the \\(y=x\\) line. Do consider, this distribution is only defined for \\(p\\in[0,1]\\). Some error handling could benefit your code’s reliability. 3.5 Measures of Central Tendency and Spread We do come across a challenge when trying to figure out expressions for these statistics. First we must derive their expression analytically because they can’t be expressed just in terms of what we have already implemented in the triangular distribution (We must evaluate definite integrals); second, because these definite integral explicitly make use of the underlying triangular distribution, they can’t be generalised to the whole family of truncated distributions; and finally, the triangular distribution is a piecewise function, meaning the procedure to derive an expression must be done on a case by case basis. 3.5.1 Mean The expected value of a random variable \\(X\\). \\[ E(X) = \\int_{-\\infty}^{\\infty}xh(x)dx = \\int_{a}^{b}x\\cdot\\frac{f(x)}{F(b)-F(a)}dx= \\frac{\\int_{a}^{b}xf(x)dx}{F(b)-F(a)} \\] Case 1 (\\(L \\leq a \\leq b &lt; M\\)): \\[ E(X)=\\frac{\\int_{a}^{b} x \\cdot \\frac{2(x-L)}{(U-L)(M-L)} dx}{F(b)-F(a)} \\] \\[ = \\frac{\\frac{2\\left( b^{3} - a^{3} - 3L\\left( \\frac{b^{2}}{2} - \\frac{a^{2}}{2} \\right) \\right)}{3(U-L)(M-L)}}{F(b)-F(a)} \\] Case 2 (\\(L \\leq a &lt; M \\leq b \\leq U\\)): \\[ E(X)=\\frac{\\int_{a}^{M} x \\cdot \\frac{2(x-L)}{(U-L)(M-L)} dx + \\int_{M}^{b} x \\cdot \\frac{2(U-x)}{(U-L)(U-M)} dx}{F(b)-F(a)} \\] \\[ = \\frac{\\frac{-M^3U-2a^3U+3La^2U+3Mb^2U-3Lb^2U+LM^3+2Ma^3-3LMa^2-2Mb^3+2Lb^3}{3(U-L)(M-L)(U-M)}}{F(b)-F(a)} \\] Case 3 (\\(M \\leq a \\leq b \\leq U\\)): \\[ E(X)=\\frac{\\int_{M}^{b} x \\cdot \\frac{2(U-x)}{(U-L)(U-M)} dx}{F(b)-F(a)} \\] \\[ = \\frac{\\frac{3b^2U-3M^2U-2b^3+2M^3}{3\\left(-L+U\\right)\\left(U-M\\right)}}{F(b)-F(a)} \\] 3.5.2 Median Value \\(x\\) such that the probability that a random variable \\(X\\) be smaller is 0.5. \\[ \\text{Median(X)} = H^{-1}(0.5) \\] This one is straight forward. We already implemented the inverse CDF. 3.5.3 Mode Value of a random variable \\(X\\) for which \\(f(x)\\) is at its maximum. Once again, we rely on the cases and calculate the mode according to where the bounds of the truncated fall. \\[ \\text{Mode(X)} = \\begin{cases} b \\quad&amp; (L \\leq a \\leq b &lt; M)\\\\ M \\quad&amp; (L \\leq a &lt; M \\leq b \\leq U)\\\\ a \\quad&amp; (M \\leq a \\leq b \\leq U) \\end{cases} \\] 3.5.4 Variance Measure of spread of the distribution with respect to the mean. \\[ \\text{Var(X)} = \\int_{-\\infty}^{\\infty}x^{2}h(x)dx - E(X)^{2} = \\int_{a}^{b}x^{2}\\cdot\\frac{f(x)}{F(b)-F(a)}dx - E(X)^{2} = \\frac{\\int_{a}^{b}x^{2}f(x)dx}{F(b)-F(a)} - E(X)^{2} \\] Case 1 (\\(L \\leq a \\leq b &lt; M\\)): \\[ \\text{Var}(X)=\\frac{\\int_{a}^{b} x^{2} \\cdot \\frac{2(x-L)}{(U-L)(M-L)} dx}{F(b)-F(a)}-E(X)^{2} \\] \\[ = \\frac{\\frac{-4L\\left(\\frac{b^3}{3}-\\frac{a^3}{3}\\right)+b^4-a^4}{2\\left(U-L\\right)\\left(M-L\\right)}}{F(b)-F(a)}-E(X)^{2} \\] Case 2 (\\(L \\leq a &lt; M \\leq b \\leq U\\)): \\[ \\text{Var}(X)=\\frac{\\int_{a}^{M} x^{2} \\cdot \\frac{2(x-L)}{(U-L)(M-L)} dx + \\int_{M}^{b} x^{2} \\cdot \\frac{2(U-x)}{(U-L)(U-M)} dx}{F(b)-F(a)}-E(X)^{2} \\] \\[ = \\frac{\\frac{-M^4U-3a^4U+4La^3U+4Mb^3U-4Lb^3U+LM^4+3Ma^4-4LMa^3-3Mb^4+3Lb^4}{6\\left(U-L\\right)\\left(M-L\\right)\\left(U-M\\right)}}{F(b)-F(a)}-E(X)^{2} \\] Case 3 (\\(M \\leq a \\leq b \\leq U\\)): \\[ \\text{Var}(X)=\\frac{\\int_{M}^{b} x^{2} \\cdot \\frac{2(U-x)}{(U-L)(U-M)} dx}{F(b)-F(a)}-E(X)^{2} \\] \\[ = \\frac{\\frac{4b^3U-4M^3U-3b^4+3M^4}{6\\left(U-L\\right)\\left(U-M\\right)}}{F(b)-F(a)}-E(X)^{2} \\] 3.6 An Object to Hold These Properties Knowing how to compute these quintessential properties of the truncated trinagular distribution, it would make sense to build them into an object to be called on demand. Luckily, all we need is a constructor function that implements these procedures and computations and returns them in a variable that can hold multiple items of different class (a list). Consider the following constructor function that, when called, stores all explored functions and values into a list and returns it. Notice how this function takes a triangular distribution object for its third parameter. The reason for this is self evident but if you’ve skipped up until this point, know that the truncated distribution is the transformation of some other distribution. ## Returns a function that returns a list with each of its elements defined as functions or vectors of one ## element that describe aspects of a truncated triangular distribution ## (pdf, cdf, inverse cdf, mean, median, mode, upper bound, lower bound, variance). generate.truncated.triangular &lt;- function(a, b, orig.tri.dist) { ## Original parameters of the triangular distribution M &lt;- orig.tri.dist$tri.mode L &lt;- orig.tri.dist$tri.lower U &lt;- orig.tri.dist$tri.upper ## Throw an error if the new bounds do not fall witin the old bounds of the triangular pdf. if (a &lt; L | b &gt; U) { stop(&quot;The new bounds of the pdf do not fall within the original range&quot;) } ## Create a function that returns the pdf of the truncated triangular, given some x. pdf &lt;- function(x) { if (a &lt; x &amp; x &lt;= b) { pdf.g &lt;- orig.tri.dist$pdf cumul.F &lt;- orig.tri.dist$cdf result &lt;- pdf.g(x) / (cumul.F(b) - cumul.F(a)) return(result) } else { result &lt;- 0 return(result) } } ## Create a function that returns the cdf of the truncated triangular, given some x. cdf &lt;- function(x) { cumul.F &lt;- orig.tri.dist$cdf if (x &lt;= a) { result &lt;- 0 } else if (a &lt; x &amp; x &lt;= b) { result &lt;- (cumul.F(x) - cumul.F(a)) / (cumul.F(b) - cumul.F(a)) } else if (b &lt; x) { result &lt;- 1 } return(result) } ## Create a function that returns the inverse cdf of the truncated triangular, given some probability p. inverse.cdf &lt;- function(p) { result &lt;- orig.tri.dist$inverse.cdf(p * (orig.tri.dist$cdf(b) - orig.tri.dist$cdf(a)) + orig.tri.dist$cdf(a)) return(result) } ## Create a vector of length 1 that describes the mean of the distribution trun.tri.mean &lt;- if (a &lt;= b &amp; b &lt; M) { result.numerator &lt;- (2 * (-3 * L * ((b ^ 2) / 2 - (a ^ 2) / 2) + b ^ 3 - a ^ 3)) / (3 * (U - L) * (M - L)) result.denominator &lt;- orig.tri.dist$cdf(b) - orig.tri.dist$cdf(a) result.numerator / result.denominator } else if (a &lt; M &amp; b &gt;= M) { result.numerator &lt;- ( -M ^ 3 * U - 2 * a ^ 3 * U + 3 * L * a ^ 2 * U + 3 * M * b ^ 2 * U - 3 * L * b ^ 2 * U + L * M ^ 3 + 2 * M * a ^ 3 - 3 * L * M * a ^ 2 - 2 * M * b ^ 3 + 2 * L * b ^ 3 ) / (3 * (U - L) * (M - L) * (U - M)) result.denominator &lt;- orig.tri.dist$cdf(b) - orig.tri.dist$cdf(a) result.numerator / result.denominator } else if (M &lt;= a &amp; a &lt;= b) { result.numerator &lt;- (3 * b ^ 2 * U - 3 * a ^ 2 * U - 2 * b ^ 3 + 2 * a ^ 3) / (3 * (U - L) * (U - M)) result.denominator &lt;- orig.tri.dist$cdf(b) - orig.tri.dist$cdf(a) result.numerator / result.denominator } ## Create a vector of length 1 that describes the median of the distribution trun.tri.median &lt;- inverse.cdf(0.5) ## Create a vector of length 1 that describes the mode of the distribution trun.tri.mode &lt;- if (a &lt;= b &amp; b &lt;= M) { b } else if (a &lt;= b &amp; b &gt;= M) { M } else if (a &gt;= M &amp; b &gt;= a) { a } ## Create a vector of length 1 that describes the upper bound of the distribution&#39;s domain trun.tri.upper &lt;- b ## Create a vector of length 1 that describes the lower bound of the distribution&#39;s domain trun.tri.lower &lt;- a ## Create a vector of length 1 that describes the variance of the distribution trun.tri.var &lt;- if (a &lt;= b &amp; b &lt; M) { result.numerator &lt;- (-4 * L * ((b ^ 3) / 3 - (a ^ 3) / 3) + b ^ 4 - a ^ 4) / (2 * (U - L) * (M - L)) result.denominator &lt;- orig.tri.dist$cdf(b) - orig.tri.dist$cdf(a) (result.numerator / result.denominator) - trun.tri.mean ^ 2 } else if (a &lt; M &amp; b &gt;= M) { result.numerator &lt;- ( -M ^ 4 * U - 3 * a ^ 4 * U + 4 * L * a ^ 3 * U + 4 * M * b ^ 3 * U - 4 * L * b ^ 3 * U + L * M ^ 4 + 3 * M * a ^ 4 - 4 * L * M * a ^ 3 - 3 * M * b ^ 4 + 3 * L * b ^ 4 ) / (6 * (U - L) * (M - L) * (U - M)) result.denominator &lt;- orig.tri.dist$cdf(b) - orig.tri.dist$cdf(a) (result.numerator / result.denominator) - trun.tri.mean ^ 2 } else if (M &lt;= a &amp; a &lt;= b) { result.numerator &lt;- (4 * (b ^ 3) * U - 4 * (a ^ 3) * U - 2 * b ^ 4 + 3 * a ^ 4) / (6 * (U - L) * (U - M)) result.denominator &lt;- orig.tri.dist$cdf(b) - orig.tri.dist$cdf(a) (result.numerator / result.denominator) - trun.tri.mean ^ 2 } ## Build the list and return it. This list contains all major properties of the truncated triangular distribution return( list( pdf = pdf, cdf = cdf, inverse.cdf = inverse.cdf, trun.tri.mean = trun.tri.mean, trun.tri.median = trun.tri.median, trun.tri.mode = trun.tri.mode, trun.tri.upper = trun.tri.upper, trun.tri.lower = trun.tri.lower, trun.tri.var = trun.tri.var ) ) } "],["simulation.html", "4 Simulation 4.1 Uniform Distribution 4.2 Pseudo-random Uniform Numbers 4.3 Pseudo-Random Variables", " 4 Simulation So far we have designed two constructor functions, generate.triangular() and generate.truncated.triangular(), with which we may create triangular distributions and truncated triangular distributions respectively. Let’s move one to some code the actually does something. Say, for example, that the truncated triangular distribution is how you chose for a random variable to behave, how long it takes for a crop to grow or the amount of rain water of a particular time period. Being able to randomly sample instances of this variable without having to wait for rainfall or for crops to grow and study how a larger system behaves as a function of this random variable could be highly beneficial and is, in fact, the basis of Monte Carlo simulation. Some definitions for this section: Let \\(Z \\sim f(x) = Triangular(2, 9, 7)\\) and \\(Z&#39; \\sim f(x|3 &lt; X \\leq 8)=h(x)\\) ## Set a seed so results are replicable set.seed(10) ## Create a list that contains the major properties of a triangular ## distribution with L = 2, U = 9, and M = 7 my.tri.dist &lt;- generate.triangular(L = 2, U = 9, M = 7) ## Create a list that contains the major properties of a truncated ## triangular distribution between a = 3 and b = 8, based on the ## previous triangular my.trun.tri.dist &lt;- generate.truncated.triangular(a = 3, b = 8, orig.tri.dist = my.tri.dist) 4.1 Uniform Distribution This may well be the most simple continuous probability density function. The uniform distribution, describes a random variable that is equiprobable at all values within an interval. This means that given an interval \\([a,b]\\), a random variable \\(X\\) can be any value greater than or equal to \\(a\\) and smaller than or equal to \\(b\\) with the same likelihood. Let’s express this mathematically! Let \\(U \\sim g(x)=Uniform(a,b)\\), where \\[ g(x) = \\begin{cases} \\frac{1}{b-a} \\quad&amp; (a\\leq x\\leq b)\\\\ 0 \\quad&amp; (x\\notin [a,b]) \\end{cases} \\] No need to implement this programatically, it is a very simple distribution that we use inderectly when generating random numbers. 4.2 Pseudo-random Uniform Numbers We’ll concern ourselves with a method to simulate a uniform random variable, the linear congruence method. This is useful to generate numbers that follow a uniform distribution which we can then transform into any distribution. Know that it is not the most widespread method, but the most simple which will result in a reliable random rumber generator. Most software will use some implementation of the Mersenne Twister if you’re looking for further reading. It is not possible to produce a sequence of numbers that is truly random. If you knew the initial conditions of a system, with enough information you could perfectly predict it. Rather, pseudo-random number generators (RNGs) take some seed (\\(X_{0}\\)) as its initial state and produces numbers from it following a deterministic procedure that is too difficult to reverse without knowing the seed. The seed is properly hidden from the target of the random numbers and so the system seems random, since they have no way to predict what the next condition will be. All following numbers are indexed as \\(X_{1},X_{2},\\cdots,X_{n}\\). The general expression for the sequence is as follows: \\[ X_{n+1} = (aX_{n}+c) \\mod m. \\] Where \\(m\\) is usually a prime number, \\(a\\) is some positive integer smaller than \\(m\\), and c is some integer in the interval \\([0,m[\\). The numbers in this sequence are not samples of a uniform random variable. The actual sequence of uniformly distributed random numbers, \\(U_{n}\\), is the following transform of the \\(X_{n}\\) sequence. \\[ U_{n}=\\frac{X_{n}}{m} \\] \\(U_{n}\\) is a sequence of uniformly distributed numbers on the interval \\([0,1[\\). If we wanted another sequence of random numbers, \\(U&#39;_{n}\\) on some other interval, \\([a,b[\\), we would do the following transform. \\[ U&#39;_{n}=U_{n} (b - a) + a \\] Notice how when \\(U_{n}\\) is very close to \\(1\\), \\(U&#39;_{n}\\) comes very close to being \\(b\\), whereas when \\(U_{n}\\) is \\(0\\), \\(U&#39;_{n}\\) is just \\(a\\), and so we now have a random sample of numbers uniformly distributed on the interval \\([a,b[\\). We also won’t implement this procedure since most programming languages already have a function to produce uniformly distributed numbers on the interval \\([0,1[\\), though knowing how one may do so will come in handy. In R, this function is runif(). One last thing to note is that one should never return \\(U_{0}\\) or \\(U&#39;_{0}\\) as a random number, since a user with malicious intent could easily derive the seed from it. 4.3 Pseudo-Random Variables Let us now consider two methods for generating samples of variables following arbitrary distributions off of a sequence of uniformly distributed random numbers, \\(U_{n}\\). 4.3.1 Inverse CDF Method You may have noticed already when studying the triangular CDF, but given a random variable \\(Y\\) with PDF \\(f(y)\\) and CDF \\(F(y)\\), the CDF produces a value on the interval \\([0,1]\\). The inverse CDF will also take a value on the interval \\([0,1]\\) and assign it a \\(y\\). Mathematicaly, \\[ F(y) = p \\Rightarrow F^{-1}\\left(F\\left(y\\right)\\right)=F^{-1}\\left(p\\right) \\Rightarrow y = F^{-1}\\left(p\\right). \\] This means that given some value between 0 and 1, we can apply the inverse CDF to it and get a matching value, \\(y\\). If we do this to all elements in a random sample of values between 0 and 1 we can get a random sample of \\(y\\)s that follow the PDF \\(f(y)\\). Let’s see this implemented in R ## 1. Generate a sequence of uniform random numbers on the interval [0, 1]. ## 10000 should be enough. U &lt;- runif(n = 10000) ## 2. Transform all elements of the U sequence with the inverse CDF ## of the truncated distribution simulated.Z.prime.Inv.CDF &lt;- sapply(U, my.trun.tri.dist$inverse.cdf) The variable simulated.Z.prime holds a sequence of numbers that follow the truncated triangular distribution defined at the start of this section. Let’s plot a histogram of this sequence along with the curve of the pdf it should ressemble. ## Plot and describe the first simulation with many bins hist(simulated.Z.prime.Inv.CDF, xlab = &quot;z&quot;, breaks = (my.trun.tri.dist$trun.tri.upper - my.trun.tri.dist$trun.tri.lower) * 10, freq = FALSE) plot.function( function(z) {sapply(z, my.trun.tri.dist$pdf)}, from = 2.99999, to = 8.0001, n = 100000, col = &quot;red&quot;, add = TRUE ) The truncated triangular PDF seems to closely fit the random sample. This is a good sign that our procedure is correct but is not enough to say for sure. 4.3.2 Trial and Error An expression for the inverse CDF of a distribution is not always easy or possible to derive. If such is the case, we execute the following procedure. One weakness of this approach is it only works for random variables on a closed, finite interval, meaning that the likes of the normal and exponential distributions can’t be simulated reliably. Also, this is a slower approach because we can’t know how long it will take until we’ve sampled enough numbers from the distribution. Luckily, the truncated distribution requires that we simulate within an interval and the expected value of iterations until we reach the desired sample size is its minimum the way it is implemented in our code. Find a constant function that is always greater than the PDF you are trying to simulate. The closer this constant is to being the max of the PDF the better. Take a uniform random number and transform it on the interval of the domain of your PDF. Take the next random uniform number, and transform it so it falls between 0 and the constant you found on step one. Evaluate if the transformed value in step three is less than or equal to the PDF evaluated on the transformed value from step two. If the condition in step four is met, add the transformed value from step 2 to your sample of the PDF. Repeat steps two through five until you have gathered your goal sample size. Let’s see this procedure implemented programatically. ## Simulate 10000 instances of a random variable with f(x) = truncated triangular by trial and error. simulated.Z.prime.t.and.e &lt;- rep(0, 10000) success.count &lt;- 0 ## Stop once we&#39;ve achieved 10000 succesful numbers while (success.count &lt; 10000) { ## Step 2 u.1 &lt;- runif( n = 1, min = my.trun.tri.dist$trun.tri.lower, max = my.trun.tri.dist$trun.tri.upper ) ## Step 3 u.2 &lt;- runif( n = 1, min = 0, max = my.trun.tri.dist$pdf(my.trun.tri.dist$trun.tri.mode) ) ## Step 4 if (u.2 &lt;= my.trun.tri.dist$pdf(u.1)) { # Step 5 success.count &lt;- success.count + 1 simulated.Z.prime.t.and.e[success.count] &lt;- u.1 } } In the case of the truncated triangular PDF we know it reaches its maximum when evaluated on its mode, meaning we can take the value \\(h(mode)\\) as the constant of step 1. Again, let’s plot these results to see how we did. ## Plot and describe the first simulation with many bins hist(simulated.Z.prime.t.and.e, xlab = &quot;z&quot;, breaks = (my.trun.tri.dist$trun.tri.upper - my.trun.tri.dist$trun.tri.lower) * 10, freq = FALSE) plot.function( function(z) {sapply(z, my.trun.tri.dist$pdf)}, from = 2.99999, to = 8.0001, n = 100000, col = &quot;red&quot;, add = TRUE ) Once again, the distribution closely ressembles the sampled data. Next, we will look into testing the hypothesis that the sample matches the distribution. Whichever method is fine for simulating or sampling PDFs, but know that each has its benefits. You would use the inverse CDF ideally on all scenarios as it is easy to implement, given an inverse CDF, but if such is not available to you or there is no interest in deriving one, the slower simulation by trial and error would still prove reliable. "],["validation.html", "5 Validation 5.1 Hypothesis test for Mean 5.2 Hypothesis test for Variance 5.3 Kolmogorov-Smirnov Test 5.4 Chi-Square Test", " 5 Validation To validate our claims that both vectors create samples that match the truncated triangular distribution, a few hypothesis tests are in order. First, we validate that the sample mean and the distribution mean match; second, we evaluate whether their variance matches. If both these tests are passed, we perform a goodness of fit test. Specifically, a Kolmogorov-Smirnof test and a Chi-Square test. 5.1 Hypothesis test for Mean 5.2 Hypothesis test for Variance 5.3 Kolmogorov-Smirnov Test 5.4 Chi-Square Test "]]
